
var net = require('net');
var parseJSON = require('utility').parseJSON;
var Q = require('q');
var hikerJoy = require('hikerJoy');
var uploadPort = hikerJoy.config.ports.fileUpload;
var utility = require('utility');

//input: [{'data':, 'type':}]
//output: ['url1', 'url2', ...]
var uploadRequest = function(files) {
    if(!files || !Array.isArray(files))
        throw new Error('file uploader accept file array as input.');

    var defer = new Q.defer();
    
    var client = new net.Socket();
    client.connect({'port': uploadPort});
    var str = JSON.stringify(files);
    var len = Buffer.byteLength(str, 'utf8');
    var buf = new Buffer(4 + len);
    buf.writeUInt32BE(len, 0);
    buf.write(str, 4, len, 'utf8');
    client.write(buf);
    var chunk = '';
    client.on('data', function(data){
        chunk += data;
    })
    .on('end', function(){
        var ret = parseJSON(chunk);
        if(!ret)
            defer.reject(new Error('file uploader no return or parse error'));
        else if(ret.err)
            defer.reject(ret.err);
        else
            defer.resolve(ret.val);
    })
    .on('error', function(err){
        defer.reject('uploadFileClient.js, socket error: ' + err);
    });

    return defer.promise;
};

var uploadSheetImage = function (sheet) {
    if(hikerJoy.validate.validateNonEmptyArray(sheet)) {
        var img = sheet.filter(function (v, k) {
            if(v && v.type === 'image' && hikerJoy.validate.validatePicUrlInBase64(v.value))
                return true;
            else 
                return false;
        });
        if(img.length === 0)
            return;
        else {
            var defer = new Q.defer();
            var uploadRequests = img.map(function (v, k) {
                return utility.getImagePostFormat(v.value);
            });
            uploadRequest(uploadRequests)
            .then(function (urls) {
                if(!Array.isArray(urls) || urls.length !== img.length) {
                    defer.reject(new Error('__uploadSheetImage got invalid return:'));
                }
                else {
                    img.forEach(function (v, k) {
                        v.value = urls[k];
                    });
                    defer.resolve(urls);
                }
            })
            .fail(function (err) {
                if (!err.expected) console.log(err.stack);
                defer.reject(err);
            });
            return defer.promise;
        }
    }
    else
        return;
};

exports.uploadRequest = uploadRequest;
exports.uploadSheetImage = uploadSheetImage;
